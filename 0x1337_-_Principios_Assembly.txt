 __       _______  _______ .___________.  ______        _______.
|  |     |   ____||   ____||           | /  __  \      /       |
|  |     |  |__   |  |__   `---|  |----`|  |  |  |    |   (----`
|  |     |   __|  |   __|      |  |     |  |  |  |     \   \    
|  `----.|  |____ |  |____     |  |     |  `--'  | .----)   |   
|_______||_______||_______|    |__|      \______/  |_______/    

-------------índice------------------

Int 0x80 - Introdução [0x1] - n4rfy
Hello World - Colocando em prática [0x2] - n4rfy
Referências - links [0x3] - n4rfy

-------------------------------------

--------------0x1--------------------
os exemplos vao ser feitos com a linguagem C, por ela ser AT&T..
basicamente irei falar sobre a interrupção 0x80, que executa uma syscall (system_call) apontada em EAX, que são:

%eax 	Name 	        %ebx 	        %ecx 	%edx 	%esx 	%edi
1 	sys_exit 	int 	- 	- 	- 	-
2 	sys_fork 	struct pt_regs 	- 	- 	- 	-
3 	sys_read 	unsigned int 	char * 	size_t 	- 	-
4 	sys_write 	unsigned int 	const char * 	size_t 	- 	-
5 	sys_open 	const char * 	int 	int 	- 	-
6 	sys_close 	unsigned int 	- 	- 	- 	-

FAQ (ou talvez ñ h4h4):
porque usar syscalls/interrupções?

para que o sistema possa ler as instruções passadas no seu programa,
seu programa não sabe agir sozinho, correto?
line feed...

----------------0x0a-----------------

----------------0x2------------------

entao, nesse exemplo irei usar a sys_write, e a sys_close, com a interrupção 0x80
em C usamos a função write(); assim: ssize_t write(int fd, const void *buf, size_t count);
em seguida a exit(): void exit(int status);
para os curiosos que quiserem ver o hexa das funções, podem consultar com:

cat /usr/include/unistd.h | grep write

bom, em assembly irá ser quase a mesma coisa, file descriptor (fd), buffer (dados), count (bytes a ser imprimidos no file descriptor)
no caso do exit, ele recebe um inteiro (status) positivo: 1, negativo: 0, a função é para simplesmente para terminar o processo.
porém com registradores, tendo em mente isso, os registradores são:

A - Acumulador
B - Base
D - Dados
C - Contador
SI - Source Index (de Source)
DI - Destination Index (para Destino)

é bom também saber que:
AX - usando o registrador inteiro, assim vale para todos.
AL - acessando o byte menos significativo desse registrador. (low-endianness)
AH - acessando o byte mais significativo desse registrador. (high-endianness)

EAX - Extended Register (E) que contém 32 bits, nesse caso um acumulador com 32 bits sendo usado completamente. (usando 32 bits) 

RAX - aqui eh o registrador de 64 bits, você já deve saber oq eh isso.

Esses são os Registradores de Uso Geral (GPR, General Purpose Registers)

bom, seguindo com o hello world (com anotações), vai funcionar da seguinte maneira:

```x86asm // imagina isso como um markdown r5r5r5r5

; comentarios em ASM sao feitos com ponto e virgula
bits 64 ; definindo o modelo como 64 bits

global _start ; entry point global = _start
_start: ; entrando no entry point

section .text ; aqui e onde se localiza nossuh codigo 
mov eax, 4 ; apontando sys_write no acumulador
mov ebx, 1 ; apontando o file descriptor, como viram no exemplo: 1, stdout (saída padrão)
mov edx, tam ; dados a ser imprimidos (tamanho da string)
mov ecx, char ; contador, que define quantos bytes irão ser imprimidos.
int 0x80 ; agora sim, a famigerada interrupção 0x80, que falei sobre acima.

; agora depois da função write, temos que fechar o processo (ou você quer executar isso pra sempre? rs)

mov eax, 1 ; apontando para sys_exit
mov ebx, 0 ; o status (inteiro) que é positivo (0)
int 0x80 ; novamente chamando o sistema pra ler isso aq que a gente tah fazendo

section .data ; aqui eh a data inicializavel
char db "ola, pessoas lendo a zine.",0x0a ; com db (declare bytes) declarei 26 bytes (incluindo espaços)
tam equ $ - char ; aqui eu pego o atual endereço da memória ($), e diminuo pelo tamanho do char (26 bytes) que também vai dar 26. com "equ" estou declarando constantes, no caso (tam) eh uma constante com o tamanho da minha string
``` 
output: 

$ nasm -f elf leetoszine.asm; ld -m elf_i386 -s -o leetoszine *.o
$ ./leetoszine
ola, pessoas lendo a zine.

---------------0x0a-------------------

-----------------0x3------------------
https://www.linuxjournal.com/article/4048
http://www.linfo.org/int_0x80.html
https://www.docow.com/48033/o-que-significa-int-0x80-no-codigo-assembly.html
----------------0x0a------------------

Gr33tZ: lynfs, usuário, kosu, KB1te, darknessxk, Nikt, nyoonki, n4rfy, v4p0r, Mark Security, p1nn1ng, demon-i686, blk, K4PP4K, MRC, Cypher

==========================================
=                  EOF                   =
==========================================
